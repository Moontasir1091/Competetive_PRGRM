#include <bits/stdc++.h>
using namespace std;
int main()
{
    int t;
    cin >> t;
    while (t--)
    {
        int n;
        cin >> n;
        vector<int> v(n);
        for (int i = 0; i < n; ++i)
        {
            cin >> v[i];
        }

        if (count(v.begin(), v.end(), v[0]) == v.size())
        {
            cout << -1 << endl;
            continue;
        }

        sort(v.begin(), v.end());
        // for(int i=0;i<n;++i){
        //     cout <<  v[i] << " ";
        // }
        // cout << endl;
        // cout << endl;
        vector<int> v2;
        int cnt = 0;
        for (int i = 1; i < n; ++i)
        {

            v2.push_back(v[i] - v[0]);
        }
        int result = v2[0];
        for (int i = 1; i < v2.size(); ++i)
        {
            result = __gcd(result, v2[i]);
        }
        cout << result << endl;
    }
}

/*

ধরি, আমাদের কাছে একটি অ্যারে আছে: 𝑎 = [ 8 , 12 , 16 , 20 ] a=[8,12,16,20]

ধাপ ১: সর্বনিম্ন মান বের করা আমরা প্রথমে অ্যারের সর্বনিম্ন মান 𝑎 𝑖 0 a i 0 ​ ​ বের করি। এখানে, সর্বনিম্ন মান হলো ৮।

 ধাপ ২: প্রতিটি উপাদান থেকে 𝑎 𝑖 0 a i 0 ​ ​ বিয়োগ করা 𝑎 𝑖 − 𝑎 𝑖 0 a i ​ −a i 0 ​ ​ প্রতিটি উপাদানের জন্য গণনা করি: 12 − 8 = 4 12−8=4 16 − 8 = 8 16−8=8 20 − 8 = 12 20−8=12 তাহলে, আমাদের নতুন সংখ্যা গুলো হলো: [ 4 , 8 , 12 ] [4,8,12]


 ধাপ ৩: এই নতুন সংখ্যা গুলোর GCD বের করা আমরা 4 , 8 , 12 4,8,12 এর গ্রেটেস্ট কমন ডিভাইসর (GCD) বের করি। GCD ( 4 , 8 , 12 ) = 4 GCD(4,8,12)=4 ফলাফল সুতরাং, সর্বোচ্চ 𝑘 k হবে ৪, কারণ এই মানটি দিয়ে প্রতিটি 𝑎 𝑖 − 𝑎 𝑖 0 a i ​ −a i 0 ​ ​ বিভাজ্য। পরীক্ষা করা (সব সংখ্যাকে সমান করা সম্ভব কিনা) আমরা 𝑘 = 4 k=4 ব্যবহার করে প্রতিটি উপাদানকে সমান করতে পারি: 12 12 থেকে 4 4 বিয়োগ করি → 12 − 4 = 8 12−4=8 16 16 থেকে 4 × 2 4×2 বিয়োগ করি → 16 − 8 = 8 16−8=8 20 20 থেকে 4 × 3 4×3 বিয়োগ করি → 20 − 12 = 8 20−12=8 অবশেষে, সব উপাদান ৮ হয়ে গেছে, তাই সমান করা সম্ভব!
*/